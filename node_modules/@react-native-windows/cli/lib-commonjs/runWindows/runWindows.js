"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 * @format
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWindowsCommand = void 0;
const build = require("./utils/build");
const chalk = require("chalk");
const deploy = require("./utils/deploy");
const commandWithProgress_1 = require("./utils/commandWithProgress");
const info = require("./utils/info");
const msbuildtools_1 = require("./utils/msbuildtools");
const runWindowsOptions_1 = require("./runWindowsOptions");
const autolink_1 = require("./utils/autolink");
function ExitProcessWithError(loggingWasEnabled) {
    if (!loggingWasEnabled) {
        console.log(`Re-run the command with ${chalk.bold('--logging')} for more information`);
    }
    process.exit(1);
}
/**
 * Performs build deploy and launch of RNW apps.
 * @param args Unprocessed args passed from react-native CLI.
 * @param config Config passed from react-native CLI.
 * @param options Options passed from react-native CLI.
 */
async function runWindows(args, config, options) {
    const verbose = options.logging;
    if (verbose) {
        commandWithProgress_1.newInfo('Verbose: ON');
    }
    if (options.info) {
        try {
            const output = await info.getEnvironmentInfo();
            console.log(output.trimEnd());
            console.log('  Installed UWP SDKs:');
            const sdks = msbuildtools_1.default.getAllAvailableUAPVersions();
            sdks.forEach(version => console.log('    ' + version));
            return;
        }
        catch (e) {
            commandWithProgress_1.newError('Unable to print environment info.\n' + e.toString());
            ExitProcessWithError(options.logging);
        }
    }
    // Get the solution file
    const slnFile = build.getAppSolutionFile(options, config);
    if (options.autolink) {
        const autolinkArgs = [];
        const autolinkConfig = config;
        const autoLinkOptions = {
            logging: options.logging,
            proj: options.proj,
            sln: options.sln,
        };
        await autolink_1.autoLinkCommand.func(autolinkArgs, autolinkConfig, autoLinkOptions);
    }
    else {
        commandWithProgress_1.newInfo('Autolink step is skipped');
    }
    const buildTools = msbuildtools_1.default.findAvailableVersion(options.arch, verbose);
    if (options.build) {
        if (!slnFile) {
            commandWithProgress_1.newError('Visual Studio Solution file not found. Maybe run "react-native windows" first?');
            ExitProcessWithError(options.logging);
        }
        try {
            await build.restoreNuGetPackages(slnFile, buildTools, verbose);
        }
        catch (e) {
            commandWithProgress_1.newError('Failed to restore the NuGet packages: ' + e.toString());
            ExitProcessWithError(options.logging);
        }
        // Get build/deploy options
        const buildType = deploy.getBuildConfiguration(options);
        var msBuildProps = build.parseMsBuildProps(options);
        // Disable the autolink check since we just ran it
        msBuildProps.RunAutolinkCheck = 'false';
        try {
            await build.buildSolution(buildTools, slnFile, buildType, options.arch, msBuildProps, verbose, undefined, // build the default target
            options.buildLogDirectory);
        }
        catch (e) {
            commandWithProgress_1.newError(`Build failed with message ${e.message}. Check your build configuration.`);
            if (e.logfile) {
                console.log('See', chalk.bold(e.logfile));
            }
            ExitProcessWithError(options.logging);
        }
    }
    else {
        commandWithProgress_1.newInfo('Build step is skipped');
    }
    await deploy.startServerInNewWindow(options, verbose);
    if (options.deploy) {
        if (!slnFile) {
            commandWithProgress_1.newError('Visual Studio Solution file not found. Maybe run "react-native windows" first?');
            ExitProcessWithError(options.logging);
        }
        try {
            if (options.device || options.emulator || options.target) {
                await deploy.deployToDevice(options, verbose);
            }
            else {
                await deploy.deployToDesktop(options, verbose, config, buildTools);
            }
        }
        catch (e) {
            commandWithProgress_1.newError(`Failed to deploy${e ? `: ${e.message}` : ''}`);
            ExitProcessWithError(options.logging);
        }
    }
    else {
        commandWithProgress_1.newInfo('Deploy step is skipped');
    }
}
/*
// Example of running the Windows Command
runWindows({
  root: 'C:\\github\\hack\\myapp',
  debug: true,
  arch: 'x86',
  nugetPath: 'C:\\github\\react\\react-native-windows\\local-cli\\runWindows\\.nuget\\nuget.exe'
});
*/
/**
 * Starts the app on a connected Windows emulator or mobile device.
 */
exports.runWindowsCommand = {
    name: 'run-windows',
    description: 'builds your app and starts it on a connected Windows desktop, emulator or device',
    func: runWindows,
    options: runWindowsOptions_1.runWindowsOptions,
};
//# sourceMappingURL=runWindows.js.map